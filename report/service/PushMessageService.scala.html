<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PushMessageService.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">service</a> &gt; <span class="el_source">PushMessageService.scala</span></div><h1>PushMessageService.scala</h1><pre class="source lang-java linenums">package service

import form._
import dao._
import model.Statics
import java.util.Locale

import utils.RegexUtil
import client.WeChatClient

import scala.concurrent.Future
import org.jmotor.i18n.Messages
import business.inapp.InAppMessageHandler
import business.push.AppPushMessageHandler
import dtos.{ PushMessageDto, UserInfo }
import exception.{ WechatAppIdInvalidException, WechatAppSecretInvalidException, WechatInvalidTokenException, WechatTokenSystemBusyException }
import io.growing.marketing.common.model._
import javax.inject.{ Inject, Singleton }
import com.typesafe.scalalogging.LazyLogging
import io.growing.micros.play.mvc.FutureUtils
import infrastructure.lock.MessageCacheManager
import io.growing.micros.play.module.FileService

import scala.concurrent.ExecutionContext.Implicits.global
import handlers.PushMessageHandler
import infrastructure.measurement.MessageMeasurementHandler
import io.growing.micros.business.model.{ Product, Project }
import io.growing.micros.play.exception.NotFoundException
import io.growing.micros.utils.conversion.GrowingConversions._
import model.context.AppMessageContext

/**
 * PushMessageService
 *
 * @author damon lin
 *         2018/12/12
 */
@Singleton
<span class="nc bnc" id="L39" title="All 4 branches missed.">class PushMessageService @Inject() (</span>
  messageCacheManager: MessageCacheManager,
<span class="nc" id="L41">  pushRuleDao: PushRuleDao,</span>
<span class="nc" id="L42">  pushMessageDao: PushMessageDao,</span>
<span class="nc" id="L43">  pushChannelDao: PushChannelDao,</span>
<span class="nc" id="L44">  pushMessageHandler: PushMessageHandler,</span>
<span class="nc" id="L45">  pushMetricsHandler: MessageMeasurementHandler,</span>
<span class="nc" id="L46">  inAppMessageHandler: InAppMessageHandler,</span>
<span class="nc" id="L47">  appPushMessageHandler: AppPushMessageHandler,</span>
<span class="nc" id="L48">  weChatClient: WeChatClient,</span>
<span class="nc" id="L49">  fileService: FileService) extends FutureUtils with LazyLogging {</span>

<span class="nc" id="L51">  private val errorMessages = Messages(&quot;i18n/common&quot;)</span>
<span class="nc" id="L52">  private val pushMessages = Messages(&quot;i18n/pushmessage&quot;)</span>

<span class="nc" id="L54">  def create(form: PushMessageForm, project: Project, userId: Int, userInfos: List[UserInfo] = List.empty, apnsProd: Boolean = true): Future[PushMessageDto] = {</span>
<span class="nc" id="L55">    val context = AppMessageContext(userId, project, form, users = userInfos, apnsProd = apnsProd)</span>
<span class="nc" id="L56">    val handler = dispatchHandler(form)</span>
    for {
<span class="nc" id="L58">      contextWithValidForm &lt;- handler.preCreateHandle(context)</span>
<span class="nc" id="L59">      contextWithMetrics ← handler.handleMetrics(contextWithValidForm)</span>
<span class="nc" id="L60">      contextWithMessage &lt;- handler.insertMessage(contextWithMetrics)</span>
<span class="nc" id="L61">      contextWithRules &lt;- handler.createRule(contextWithMessage)</span>
<span class="nc" id="L62">      contextToBeDone &lt;- handler.afterCreateHandle(contextWithRules)</span>
    } yield {
<span class="nc" id="L64">      contextToBeDone.toPresenter</span>
    }
  }

  def update(form: PushMessageForm, messageId: Int, project: Project, userId: Int): Future[PushMessageDto] = {
<span class="nc" id="L69">    val context = AppMessageContext(userId, project, form)</span>
<span class="nc" id="L70">    val handler = dispatchHandler(form)</span>
    for {
<span class="nc" id="L72">      contextWithValidForm &lt;- handler.preUpdateHandle(context, messageId)</span>
<span class="nc" id="L73">      contextWithMessage &lt;- handler.updateMessage(contextWithValidForm)</span>
<span class="nc" id="L74">      contextWithRules &lt;- handler.updateRule(contextWithMessage)</span>
<span class="nc" id="L75">      contextToBeDone &lt;- handler.afterUpdateHandle(contextWithRules)</span>
<span class="nc" id="L76">      result ← findByProjectAndId(project.dbid, contextToBeDone.getMessage.dbid, contextToBeDone.audienceFilter)</span>
    } yield {
<span class="nc" id="L78">      result.get.copy(from = contextToBeDone.from)</span>
    }
  }

  private def dispatchHandler(form: PushMessageForm) = {
<span class="nc" id="L83">    form.`type` match {</span>
<span class="nc bnc" id="L84" title="All 6 branches missed.">      case MessageType.push =&gt; appPushMessageHandler</span>
<span class="nc" id="L85">      case _ =&gt; inAppMessageHandler</span>
    }
  }

<span class="nc" id="L89">  def findByProject(projectId: Int, filter: Option[PushFilterForm] = None): Future[List[PushMessageDto]] = {</span>
<span class="nc" id="L90">    pushMessageDao.findByProjectId(projectId).flatMap { messages =&gt;</span>
<span class="nc" id="L91">      convertToDTOs(messages)</span>
    }
  }

  def findByCampaign(projectId: Int, campaignId: Int): Future[List[PushMessageDto]] = {
<span class="nc" id="L96">    pushMessageDao.findByCampaign(projectId, campaignId).flatMap { messages =&gt;</span>
<span class="nc" id="L97">      convertToDTOs(messages.toList)</span>
    }
  }

  def findByMessageIds(projectId: Int, messageIds: Seq[Int]): Future[List[PushMessageDto]] = {
<span class="nc" id="L102">    pushMessageDao.findMessagesByMsgIds(projectId, messageIds).flatMap { messages =&gt;</span>
<span class="nc" id="L103">      convertToDTOs(messages.toList)</span>
    }
  }

  private def convertToDTOs(messages: List[PushMessage]): Future[List[PushMessageDto]] = {
<span class="nc" id="L108">    Future.traverse(messages) { message =&gt;</span>
<span class="nc" id="L109">      val filter = pushMessageHandler.convertFilterToForm(message.audienceFilter)</span>
      for (
<span class="nc" id="L111">        rules &lt;- pushRuleDao.findByMessageId(message.dbid);</span>
<span class="nc" id="L112">        metrics &lt;- pushMetricsHandler.findById(message.metricsRef)</span>
<span class="nc" id="L113">      ) yield PushMessageDto(message, rules, metrics, filter)</span>
    }
  }

<span class="nc" id="L117">  def findByProjectAndId(projectId: Int, messageId: Int, filter: Option[PushFilterForm] = None): Future[Option[PushMessageDto]] = {</span>
<span class="nc" id="L118">    pushMessageDao.findById(messageId, projectId).flatMap { maybeMessage =&gt;</span>
<span class="nc" id="L119">      Future.traverse(maybeMessage.toSeq) { message =&gt;</span>
<span class="nc" id="L120">        val filter = pushMessageHandler.convertFilterToForm(message.audienceFilter)</span>
        for (
<span class="nc" id="L122">          rules &lt;- pushRuleDao.findByMessageId(message.dbid);</span>
<span class="nc" id="L123">          metrics &lt;- pushMetricsHandler.findById(message.metricsRef)</span>
<span class="nc" id="L124">        ) yield PushMessageDto(message, rules, metrics, filter)</span>
<span class="nc" id="L125">      }.map(_.headOption)</span>
    }
  }

  def deleteById(projectId: Int, messageId: Int, userId: Int)(implicit locale: Locale): Future[Int] = {
    for (
<span class="nc" id="L131">      maybeMessage &lt;- pushMessageDao.findById(messageId, projectId);</span>
<span class="nc" id="L132">      _ &lt;- failCondition(maybeMessage.isEmpty, NotFoundException(errorMessages.format(&quot;notFound&quot;)));</span>
<span class="nc" id="L133">      count &lt;- pushMessageDao.archived(messageId, projectId, userId);</span>
<span class="nc" id="L134">      _ &lt;- pushRuleDao.deleteByMessageId(maybeMessage.get.dbid)</span>
    // TODO: delete files
    ) yield {
<span class="nc" id="L137">      count</span>
    }
  }

<span class="nc" id="L141">  def updateMinpPreviewUrl(projectId: Int, messageId: Int, productId: Int, userId: Int)(implicit locale: Locale): Future[Either[String, String]] = {</span>
<span class="nc" id="L142">    pushRuleDao.findByMessageId(messageId).map(rules =&gt; rules.find(_.productId.contains(productId)).flatMap(_.wxQrCode))</span>
<span class="nc" id="L143">      .flatMap {</span>
        //先找rule表里对应product之前有没有生成过wxQrCode，生成过就直接返回，没生成过就生成一下更新到表里再返回
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case Some(s) =&gt; Future.successful(Right(s))</span>
<span class="nc" id="L146">        case _ =&gt; pushChannelDao.findByProductAndName(projectId, productId, Statics.ChannelName.WeChatMinP)</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">          .map(_.filter(c =&gt; c.appKey.trim.nonEmpty &amp;&amp; c.appSecret.trim.nonEmpty))</span>
<span class="nc" id="L148">          .flatMap {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            case Some(channel) =&gt; createAndUploadWeChatProgramImage(channel, projectId, messageId)</span>
<span class="nc" id="L150">              .flatMap(link =&gt; pushRuleDao.updateWxQrCode(messageId, productId, link, userId).map(_ =&gt; link)).map(Right(_))</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">              .recover {</span>
                // 小程序微信相关的问题 用warnings
<span class="nc bnc" id="L153" title="All 4 branches missed.">                case e1: WechatTokenSystemBusyException =&gt;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                  logger.warn(pushMessages.format(&quot;WeChatSystemBusy&quot;))</span>
<span class="nc" id="L155">                  Left(e1.message)</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">                case e2: WechatAppSecretInvalidException =&gt;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                  logger.warn(pushMessages.format(&quot;WeChatAppsecretInvalid&quot;))</span>
<span class="nc" id="L158">                  Left(e2.message)</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">                case e3: WechatAppIdInvalidException =&gt;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                  logger.warn(pushMessages.format(&quot;WeChatAppIdInvalid&quot;))</span>
<span class="nc" id="L161">                  Left(e3.message)</span>
                // 用获取的token进行查询二维码的异常
<span class="nc bnc" id="L163" title="All 4 branches missed.">                case e4: WechatInvalidTokenException =&gt;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                  logger.error(pushMessages.format(&quot;WeChatTokenInvalid&quot;), e4)</span>
<span class="nc" id="L165">                  Left(e4.message)</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">                case e5: Throwable =&gt;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                  logger.error(pushMessages.format(&quot;WeChatPreviewImageFailed&quot;), e5)</span>
<span class="nc" id="L168">                  Left(&quot;生成小程序二维码失败&quot;)</span>
              }
<span class="nc" id="L170">            case _ =&gt; Future.successful(Left(&quot;小程序appid和secret未配置&quot;))</span>
          }
      }
  }

  def countOnlinePushMessage(projectId: Int): Future[Int] = {
<span class="nc" id="L176">    pushMessageDao.countOnlineByType(projectId, MessageType.push)</span>
  }

  def countOnlineInAppMessage(projectId: Int): Future[Int] = {
<span class="nc" id="L180">    pushMessageDao.countOnlineByType(projectId, MessageType.popupWindow)</span>
  }

  private def createAndUploadWeChatProgramImage(pushChannel: PushChannel, projectId: Int, messageId: Int): Future[String] = {
    for {
<span class="nc" id="L185">      token &lt;- weChatClient.getAccessToken(pushChannel.appKey, pushChannel.appSecret)</span>
<span class="nc" id="L186">      imageByte &lt;- weChatClient.getQrCodeImage(token, s&quot;gioMessageId=${messageId.toUid}&quot;)</span>
<span class="nc" id="L187">      url &lt;- fileService.upload(&quot;media&quot;, RegexUtil.genPrefix(projectId),</span>
<span class="nc" id="L188">        RegexUtil.genFileName(&quot;img.jpeg&quot;), imageByte.toArray, shared = &quot;true&quot;)</span>
<span class="nc" id="L189">    } yield url</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>