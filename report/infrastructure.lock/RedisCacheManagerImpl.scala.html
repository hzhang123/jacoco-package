<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisCacheManagerImpl.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">infrastructure.lock</a> &gt; <span class="el_source">RedisCacheManagerImpl.scala</span></div><h1>RedisCacheManagerImpl.scala</h1><pre class="source lang-java linenums">package infrastructure.lock

import java.util.UUID

import akka.actor.ActorSystem
import com.typesafe.scalalogging.LazyLogging
import io.growing.micros.middleware.cache.RedisConfigs
import javax.inject.{ Inject, Singleton }
import redis.protocol.Integer
import redis.{ RedisClientPool, RedisServer }

import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

/**
 *
 * 分布式锁 redis实现
 *
 * @author wusi
 * @since 2019-05-28 17:31
 */
@Singleton
<span class="fc bfc" id="L23" title="All 4 branches covered.">class RedisCacheManagerImpl @Inject() (redisConfigs: RedisConfigs) extends LockManager</span>
  with MessageCacheManager with LazyLogging {

<span class="pc" id="L26">  private val MODIFY_SUCCESS = &quot;1&quot;</span>
<span class="fc" id="L27">  private val RELEASE_SCRIPT = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;</span>
  //改下key名防止和以前key名冲突，之前的锁没有过期时间，新的锁如果重名SETNX会一直失败
<span class="fc" id="L29">  private val LOCK_PREFIX = &quot;REDIS_LOCK_PREFIX_&quot;</span>
<span class="pc" id="L30">  private val MESSAGE_PREFIX = &quot;MESSAGE_PREFIX_&quot;</span>
<span class="fc" id="L31">  implicit val akkaSystem: ActorSystem = akka.actor.ActorSystem()</span>
<span class="fc" id="L32">  private val redisClient = RedisClientPool(Seq(RedisServer(redisConfigs.getDefaultRedisConfig.host, redisConfigs.getDefaultRedisConfig.port)))</span>

  /**
   *
   * 获取锁
   *
   * @param key              获取锁的key
   * @param expireTimeMillis 锁的失效时间，单位是毫秒
   * @return 获取的锁，获取不到返回None
   *
   */
<span class="fc" id="L43">  override def acquire(key: String, expireTimeMillis: Long = DEFAULT_EXPIRY_TIME_MILLIS): Future[Option[Lock]] = {</span>
<span class="fc" id="L44">    val lock = Lock(enrichLockKey(key), UUID.randomUUID().toString)</span>
<span class="fc" id="L45">    redisClient.set(lock.key, lock.uid, pxMilliseconds = Some(expireTimeMillis), NX = true).map {</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">      case true =&gt;</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">        logger.debug(&quot;acquire lock {} {} success&quot;, lock.key, lock.uid: Any)</span>
<span class="fc" id="L48">        Some(lock)</span>
      case _ =&gt;
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">        logger.debug(&quot;acquire lock {} {} failed&quot;, lock.key, lock.uid: Any)</span>
<span class="fc" id="L51">        None</span>
    }
  }

  /**
   *
   * 释放锁
   *
   * @param lock 获取的锁,不能为空
   * @return 释放是否成功,成功 true; 失败 false
   *
   */
  override def release(lock: Lock): Future[Boolean] = {
<span class="fc" id="L64">    val result = redisClient.eval(RELEASE_SCRIPT, Seq(lock.key), Seq(lock.uid))</span>
<span class="fc" id="L65">    result.map {</span>
<span class="pc bpc" id="L66" title="2 of 4 branches missed.">      case s: Integer if s.toBoolean =&gt;</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        logger.debug(&quot;release lock {} {} success&quot;, lock.key, lock.uid: Any)</span>
<span class="fc" id="L68">        true</span>
      case _ =&gt;
<span class="nc bnc" id="L70" title="All 2 branches missed.">        logger.warn(&quot;release lock {} {} failed&quot;, lock.key, lock.uid: Any)</span>
<span class="nc" id="L71">        false</span>
    }
  }

  override def sendMessage(queueName: String, message: String): Future[Boolean] = {
<span class="nc bnc" id="L76" title="All 2 branches missed.">    logger.info(&quot;sendMessage queueName: &quot; + queueName)</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">    logger.info(&quot;sendMessage message: &quot; + message)</span>
<span class="nc" id="L78">    val result = redisClient.lpush(enrichMessageKey(queueName), message)</span>
<span class="nc" id="L79">    result.map(_.toString).map {</span>
<span class="nc bnc" id="L80" title="All 6 branches missed.">      case MODIFY_SUCCESS =&gt; true</span>
<span class="nc" id="L81">      case _ =&gt; false</span>
    }
  }

  private def enrichLockKey(key: String): String = {
<span class="fc" id="L86">    LOCK_PREFIX + key</span>
  }

  private def enrichMessageKey(key: String): String = {
<span class="nc" id="L90">    MESSAGE_PREFIX + key</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>