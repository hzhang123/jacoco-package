<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComputeDao.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">dao</a> &gt; <span class="el_source">ComputeDao.scala</span></div><h1>ComputeDao.scala</h1><pre class="source lang-java linenums">package dao

import io.growing.micros.business.model.Status
import io.growing.micros.business.model.Status.Status
import io.growing.micros.play.slickpg.GrowingPostgresDriver
import io.growing.micros.play.slickpg.GrowingPostgresDriver.api._
import io.growing.micros.utils.time.DateTimeUtil.UTCNow
import javax.inject.{ Inject, Singleton }
import model.insight.ComputableType.ComputableType
import model.insight.SchedulerType.SchedulerType
import model.insight._
import play.api.db.slick.{ DatabaseConfigProvider, HasDatabaseConfigProvider }
import play.api.libs.json.{ JsValue, Json }
import slick.lifted.{ Rep, TableQuery, Tag }

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

/**
 * @author : xhldtc
 * @since : 2019/11/18
 */
<span class="nc" id="L23">class ComputesTable(tag: Tag) extends BaseTable[Compute](tag, &quot;marketing_computes&quot;) {</span>

<span class="nc" id="L25">  implicit val ComputableTypeE = MappedColumnType.base[ComputableType, String](</span>
<span class="nc" id="L26">    e =&gt; e.toString,</span>
<span class="nc" id="L27">    s =&gt; ComputableType.withName(s))</span>

<span class="nc" id="L29">  implicit val SchedulerTypeE = MappedColumnType.base[SchedulerType, String](</span>
<span class="nc" id="L30">    e =&gt; e.toString,</span>
<span class="nc" id="L31">    s =&gt; SchedulerType.withName(s))</span>

<span class="nc" id="L33">  implicit val conversionDefinition = MappedColumnType.base[Definition, JsValue](</span>
<span class="nc" id="L34">    e =&gt; Json.toJson(e),</span>
<span class="nc" id="L35">    s =&gt; s.as[Definition])</span>

<span class="nc" id="L37">  def `type`: Rep[ComputableType] = column[ComputableType](&quot;type&quot;)</span>

<span class="nc" id="L39">  def ai: Rep[String] = column[String](&quot;ai&quot;)</span>

<span class="nc" id="L41">  def key: Rep[String] = column[String](&quot;key&quot;)</span>

<span class="nc" id="L43">  def definition: Rep[Definition] = column[Definition](&quot;definition&quot;)</span>

<span class="nc" id="L45">  def scheduler: Rep[SchedulerType] = column[SchedulerType](&quot;scheduler&quot;)</span>

<span class="nc" id="L47">  def hits: Rep[Int] = column[Int](&quot;hits&quot;)</span>

<span class="nc" id="L49">  def status: Rep[Status] = column[Status](&quot;status&quot;)</span>

<span class="nc" id="L51">  override def * = (id.?, projectId, `type`, ai, key, definition, scheduler, hits,</span>
<span class="nc" id="L52">    creatorId, updaterId, status, createdAt, updatedAt) &lt;&gt; ((Compute.apply _).tupled, Compute.unapply)</span>
}

@Singleton
<span class="nc" id="L56">class ComputeDao @Inject() (override protected val dbConfigProvider: DatabaseConfigProvider)</span>
<span class="nc" id="L57">  extends BaseDao[ComputesTable, Compute] with HasDatabaseConfigProvider[GrowingPostgresDriver] {</span>

<span class="nc" id="L59">  override val table = TableQuery[ComputesTable]</span>

  override def findByProject(projectId: Int): Future[List[Compute]] = {
<span class="nc" id="L62">    db.run(table.filter(t =&gt; t.projectId === projectId &amp;&amp; t.status =!= Status.archived).result).map(_.toList)</span>
  }

  def updateStatus(projectId: Int, id: Int, status: Status, userId: Int): Future[Int] = {
<span class="nc" id="L66">    db.run(table.filter(t =&gt; t.projectId === projectId &amp;&amp; t.id === id)</span>
<span class="nc" id="L67">      .map(t =&gt; (t.status, t.updatedAt, t.updaterId))</span>
<span class="nc" id="L68">      .update(status, UTCNow, userId))</span>
  }

  override def update(projectId: Int, id: Int, model: Compute): Future[Int] = {
<span class="nc" id="L72">    db.run(findAction(projectId, id).update(model))</span>
  }

  override def deleteById(projectId: Int, id: Int): Future[Int] = {
<span class="nc" id="L76">    db.run(findAction(projectId, id).map(_.status).update(Status.archived))</span>
  }

  override def batchDelete(models: Seq[Compute]): Future[Int] = {
<span class="nc" id="L80">    val ids = models.map(_.id.get)</span>
<span class="nc" id="L81">    db.run(table.filter(_.id inSet ids).delete)</span>
  }

  private[this] def findAction(projectId: Int, id: Int) = {
<span class="nc" id="L85">    table.filter(t =&gt; t.projectId === projectId &amp;&amp; t.id === id &amp;&amp; !t.status.inSet(List(Status.archived, Status.deleted)))</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>