<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PushResultListenerActor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">actors.job</a> &gt; <span class="el_source">PushResultListenerActor.scala</span></div><h1>PushResultListenerActor.scala</h1><pre class="source lang-java linenums">package actors.job

import java.util
import java.util.{ Properties, UUID }

import actors.Injector
import akka.actor.Props
import com.typesafe.config.Config
import dao.{ PushApiRequestDao, PushJobDao, PushMessageDao, PushTaskDao }
import dtos.Messages.PushResult
import infrastructure.kafka.deserializer.PushResultDeserializer
import infrastructure.lock.EmptyLockManagerImpl
import io.growing.marketing.common.model.PushTask
import io.growing.micros.business.model.Status
import io.growing.micros.utils.conversion.GrowingConversions._
import io.growing.micros.utils.time.DateTimeUtil.UTCNow
import javax.inject.Inject
import model.Statics
import org.apache.kafka.clients.consumer.KafkaConsumer
import org.apache.kafka.common.serialization.StringDeserializer
import utils.MessageChecker

import scala.collection.JavaConverters._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

/**
 * PushResultListenerActor
 *
 * @author damon lin
 *         2019/5/24
 */
<span class="pc bpc" id="L33" title="1 of 4 branches missed.">class PushResultListenerActor @Inject() (</span>
<span class="fc" id="L34">  injector: Injector,</span>
<span class="fc" id="L35">  config: Config,</span>
<span class="fc" id="L36">  pushMessageDao: PushMessageDao,</span>
<span class="fc" id="L37">  pushTaskDao: PushTaskDao,</span>
<span class="fc" id="L38">  pushJobDao: PushJobDao,</span>
<span class="fc" id="L39">  pushApiRequestDao: PushApiRequestDao,</span>
<span class="fc" id="L40">  messageChecker: MessageChecker) extends AbstractTimerActor {</span>

  import PushResultListenerActor._

<span class="pc" id="L44">  val SuccessCode = &quot;200&quot;</span>
<span class="fc" id="L45">  val POLL_TIMEOUT = 2000L</span>
<span class="fc" id="L46">  var kafkaConsumer: KafkaConsumer[String, PushResult] = _</span>
<span class="fc" id="L47">  override val lockManager = new EmptyLockManagerImpl()</span>

<span class="fc" id="L49">  override val TimerKey: Any = ResultListenerTickKey</span>
<span class="fc" id="L50">  override val delayMillis: Int = 500</span>
<span class="fc" id="L51">  override val intervalSeconds: Int = 20</span>

  override def initJob(): Unit = {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">    logger.info(&quot;start push result listener actor ...&quot;)</span>
<span class="fc" id="L55">    val properties: Properties = initProperties()</span>
<span class="fc" id="L56">    kafkaConsumer = new KafkaConsumer[String, PushResult](properties)</span>
<span class="fc" id="L57">    kafkaConsumer.subscribe(util.Arrays.asList(Statics.TOPIC_PUSH_RESULT))</span>
  }

  /**
   * 推送返回的结果的状态比较多，按以下逻辑处理
   * 1.code是success 并且failedAudienceMap为空，代表全量成功，更新task状态为finished,不重试
   * 2.code是success 但是failedAudienceMap不为空，代表部分成功，更新task状态为finished,创建重试子task，audience为失败设备token
   * 3.code是failed 代表推送失败了，更新task状态为failed, 创建重试子task，如果failedAudienceMap不为空就用map里的audience重试，如
   * 果为空就用父task的所有token全量重试
   * @return
   */
  override def tickJob(): Future[Any] = {
    // 本地开发和测试环境公用一套 kafka 所以会被测试实例消费掉 拉不到数据
<span class="fc" id="L70">    val results = kafkaConsumer.poll(POLL_TIMEOUT).asScala</span>
<span class="pc bnc" id="L71" title="All 2 branches missed.">      .filter { record =&gt; !messageChecker.consumed(record.key(), Statics.TOPIC_PUSH_RESULT) }</span>
<span class="pc bnc" id="L72" title="All 2 branches missed.">      .filter { record =&gt; !messageChecker.consumed(record.value().getTaskId, Statics.TOPIC_PUSH_RESULT) }</span>

<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    if (results.nonEmpty) {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      logger.info(s&quot;${this.getClass.getSimpleName} pull results: ${results.size} .&quot;)</span>
<span class="nc" id="L76">      val tasks = results.map(_.value())</span>
<span class="nc bnc" id="L77" title="All 8 branches missed.">      val (successfulTasks, failedTasks) = tasks.partition(_.getCode == SuccessCode)</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      if (failedTasks.nonEmpty) {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        logger.warn(s&quot;failedTasks: ${failedTasks.map(_.getTaskId).mkString(&quot;,&quot;)}&quot;)</span>
      }
<span class="nc bnc" id="L81" title="All 2 branches missed.">      val (_, partiallyFailedTasks) = successfulTasks.partition(_.getFailedAudienceMap.isEmpty)</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      if (partiallyFailedTasks.nonEmpty) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        logger.warn(s&quot;partiallyFailedTasks: ${partiallyFailedTasks.map(_.getTaskId).mkString(&quot;,&quot;)}&quot;)</span>
      }
<span class="nc" id="L85">      val successfulIds = successfulTasks.map(_.getTaskId).toSeq</span>
<span class="nc" id="L86">      debugInfo(successfulIds, failedTasks.toSeq)</span>
      // todo: 因为返回的任务结果是乱序的 所以更新 job 的状态放到管理后台的 index 接口里做
      for {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        _ &lt;- pushTaskDao.updateSuccessfulTasks(successfulIds)</span>
<span class="nc" id="L90">        tasksGroupByReason = failedTasks.groupBy(_.getReason).toList</span>
<span class="nc" id="L91">        _ &lt;- updateFailedTasks(tasksGroupByReason)</span>
<span class="nc" id="L92">        _ &lt;- Future.traverse(failedTasks)(buildAndSaveRetryTask)</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        _ &lt;- Future.traverse(partiallyFailedTasks)(buildAndSaveRetryTask)</span>
<span class="nc" id="L94">        taskMessageIds = tasks.toSeq.map(_.getMessageId.toId).distinct</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        pushApiRequests &lt;- pushApiRequestDao.findByMessageIds(taskMessageIds)</span>
<span class="nc" id="L96">        pushApiRequestMessageIds = pushApiRequests.flatMap(_.messageId).distinct</span>
        //处理pushTask的时候把pushApi相关的message过滤掉，只处理web普通推送message,因为api推送可能分多批，不应该马上把message停掉
<span class="nc" id="L98">        _ &lt;- updateMessagesState(taskMessageIds.filterNot(pushApiRequestMessageIds.contains(_)))</span>
      } yield {
        // commit manually to make ensure at least once
<span class="nc" id="L101">        kafkaConsumer.commitAsync()</span>
      }
    } else {
<span class="fc" id="L104">      Future.successful(Unit)</span>
    }
  }

  private[this] def buildAndSaveRetryTask(pushResult: PushResult): Future[Any] = {
<span class="nc" id="L109">    val taskId = pushResult.getTaskId</span>
    for {
<span class="nc" id="L111">      maybePushTask &lt;- pushTaskDao.findByTaskId(taskId)</span>
    } yield {
<span class="nc" id="L113">      maybePushTask match {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        case Some(parentTask) =&gt;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">          if (parentTask.retryTimes &gt;= injector.configParams.pushTaskRetries) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            logger.warn(s&quot;task $taskId failed after max retry times&quot;)</span>
<span class="nc" id="L117">            pushTaskDao.updateTaskReason(taskId, &quot;exceed max retry times&quot;)</span>
          } else {
<span class="nc" id="L119">            val subTask = buildSubRetryTask(parentTask, pushResult)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            logger.info(s&quot;building subtask ${subTask.taskId} of parent task $taskId&quot;)</span>
<span class="nc" id="L121">            pushTaskDao.insert(subTask)</span>
          }
        case _ =&gt;
<span class="nc bnc" id="L124" title="All 2 branches missed.">          logger.warn(s&quot;failed to found origin task $taskId&quot;)</span>
<span class="nc" id="L125">          Future.successful(Unit)</span>
      }
    }
  }

  private[this] def buildSubRetryTask(pushTask: PushTask, pushResult: PushResult): PushTask = {
<span class="nc" id="L131">    pushTask.copy(</span>
<span class="nc" id="L132">      id = None,</span>
<span class="nc" id="L133">      taskId = UUID.randomUUID().toString,</span>

      /**
       * 如果返回的pushResult里带了失败设备的信息，就用失败的设备build task，如果没返回，那就是推送厂商的API不支持返回失败token，只
       * 给你一个失败的code，那就put之前task的所有token再重试
       */
<span class="nc bnc" id="L139" title="All 2 branches missed.">      audience = if (pushResult.getFailedAudienceMap.isEmpty) pushTask.audience else pushResult.getFailedAudienceMap.keySet().asScala.toList,</span>
<span class="nc" id="L140">      state = Status.needRetry,</span>
<span class="nc" id="L141">      reason = &quot;&quot;,</span>
<span class="nc" id="L142">      retryTimes = pushTask.retryTimes + 1,</span>
<span class="nc" id="L143">      createdAt = UTCNow,</span>
<span class="nc" id="L144">      updatedAt = UTCNow)</span>
  }

  private[this] def updateFailedTasks(groupByReason: List[(String, Iterable[PushResult])]): Future[List[Int]] = {
<span class="nc bnc" id="L148" title="All 2 branches missed.">    Future.traverse(groupByReason) {</span>
<span class="nc" id="L149">      case (reason, subFailedTasks) =&gt;</span>
<span class="nc" id="L150">        pushTaskDao.updateFailedTasks(subFailedTasks.map(_.getTaskId).toSeq, reason)</span>
    }
  }

  // 如果一条消息没有已经没有对应的 planning 状态的 task 就认为已经完成了(需要排除掉循环推送的message,job表可以更新为finish,message表不能更新，否则下次就不能循环推了)
  private[this] def updateMessagesState(messageIds: Seq[Int]): Future[_] = {
    for {
<span class="nc" id="L157">      planningMessageIds &lt;- pushTaskDao.findPlanningMessageIds(messageIds)</span>
<span class="nc" id="L158">      dailyPushMessageIds &lt;- injector.pushRuleDao.findActiveDailyRuleMessageIds()</span>
    } yield {
<span class="nc" id="L160">      val finishedJobMessageIds = messageIds.filterNot(planningMessageIds.contains(_))</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      logger.info(s&quot;update finished job messageIds: ${finishedJobMessageIds.mkString(&quot;;&quot;)}&quot;)</span>
<span class="nc" id="L162">      pushJobDao.updateToFinishedByMessageIds(finishedJobMessageIds)</span>
<span class="nc" id="L163">      val finishedMessageIds = finishedJobMessageIds.filterNot(dailyPushMessageIds.contains(_))</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      logger.info(s&quot;update finished messages: ${finishedMessageIds.mkString(&quot;;&quot;)}&quot;)</span>
<span class="nc" id="L165">      pushMessageDao.updateActivatedToStop(finishedMessageIds)</span>
    }
  }

  private[this] def debugInfo(successfulIds: Seq[String], failedTasks: Seq[PushResult]) = {
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (successfulIds.nonEmpty) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      logger.info(s&quot;update success tasks: ${successfulIds.mkString(&quot;::&quot;)} .&quot;)</span>
    }
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (failedTasks.nonEmpty) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      logger.info(s&quot;update failed tasks: ${failedTasks.map(_.getTaskId).mkString(&quot;::&quot;)} .&quot;)</span>
    }
  }

  private def initProperties() = {
<span class="fc" id="L179">    val properties = new Properties()</span>
<span class="fc" id="L180">    properties.put(&quot;bootstrap.servers&quot;, config.getStringList(&quot;channel.kafka.brokers&quot;).asScala.mkString(&quot;,&quot;))</span>
<span class="fc" id="L181">    properties.put(&quot;group.id&quot;, injector.configParams.pushResultConsumerGroupId)</span>
<span class="fc" id="L182">    properties.put(&quot;enable.auto.commit&quot;, &quot;true&quot;) // enable auto commit</span>
<span class="fc" id="L183">    properties.put(&quot;auto.commit.interval.ms&quot;, &quot;60000&quot;) // 1 minute</span>
<span class="fc" id="L184">    properties.put(&quot;session.timeout.ms&quot;, &quot;300000&quot;) // 5 minutes</span>
<span class="fc" id="L185">    properties.put(&quot;key.deserializer&quot;, classOf[StringDeserializer])</span>
<span class="fc" id="L186">    properties.put(&quot;value.deserializer&quot;, classOf[PushResultDeserializer])</span>
<span class="fc" id="L187">    properties</span>
  }
}

<span class="nc" id="L191">object PushResultListenerActor {</span>

<span class="pc" id="L193">  private case object ResultListenerTickKey</span>

<span class="fc" id="L195">  def props(injector: Injector, config: Config, pushMessageDao: PushMessageDao, pushTaskDao: PushTaskDao,</span>
<span class="nc" id="L196">    pushJobDao: PushJobDao, pushApiRequestDao: PushApiRequestDao, messageChecker: MessageChecker) = Props[PushResultListenerActor](</span>
<span class="nc" id="L197">    new PushResultListenerActor(injector, config, pushMessageDao, pushTaskDao, pushJobDao, pushApiRequestDao, messageChecker))</span>
<span class="nc" id="L198">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>