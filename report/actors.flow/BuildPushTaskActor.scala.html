<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BuildPushTaskActor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">actors.flow</a> &gt; <span class="el_source">BuildPushTaskActor.scala</span></div><h1>BuildPushTaskActor.scala</h1><pre class="source lang-java linenums">package actors.flow

import actors.Injector
import actors.protocol.JobProtocols.TasksNeedCheckpoint
import akka.actor.{ Actor, ActorRef, Props }
import com.typesafe.scalalogging.LazyLogging
import dtos.Messages.PushTaskRequest
import dtos.{ PushTaskRequestDto, UserInfo }
import io.growing.marketing.common.model._
import javax.inject.Inject
import org.apache.commons.lang3.StringUtils

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

/**
 * @author : xhldtc
 * @since : 2019/11/5
 */
<span class="pc bnc" id="L20" title="All 4 branches missed.">class BuildPushTaskActor @Inject() (injector: Injector) extends Actor with LazyLogging {</span>

<span class="pc" id="L22">  private val pushMessageDao = injector.pushMessageDao</span>
<span class="pc" id="L23">  private val productDao = injector.productDao</span>
<span class="pc" id="L24">  private val pushChannelDao = injector.pushChannelDao</span>
<span class="pc" id="L25">  private val pushRuleDao = injector.pushRuleDao</span>
<span class="pc" id="L26">  private val pushJobDao = injector.pushJobDao</span>
<span class="pc" id="L27">  private val messageDuplicateService = injector.messageDuplicateService</span>
<span class="pc" id="L28">  private val appPushMessageService = injector.appPushMessageService</span>

<span class="pc bpc" id="L30" title="1 of 2 branches missed.">  override def receive: Receive = {</span>
<span class="nc bnc" id="L31" title="All 6 branches missed.">    case dto: PushTaskRequestDto =&gt; process(dto.pushTaskRequest, dto.userInfo, sender()).recover {</span>
<span class="nc bnc" id="L32" title="All 6 branches missed.">      case t: Throwable =&gt; logger.error(s&quot;handle push task request failed: ${dto.pushTaskRequest.toString}&quot;, t)</span>
    }
  }

  private def process(pushTaskRequest: PushTaskRequest, userInfos: Seq[UserInfo], sender: ActorRef): Future[Any] = {
<span class="nc" id="L37">    val projectId = pushTaskRequest.getProjectId</span>
<span class="nc" id="L38">    val jobId = pushTaskRequest.getJobId</span>
    for {
<span class="nc" id="L40">      pushMessage &lt;- pushMessageDao.findByMsgId(pushTaskRequest.getMessageId)</span>
<span class="nc" id="L41">      validUsers &lt;- filterValidUserInfo(userInfos, pushMessage)</span>
<span class="nc" id="L42">      pushRules &lt;- pushRuleDao.findByMessageId(pushTaskRequest.getMessageId)</span>
<span class="nc" id="L43">        .map(pushRules =&gt; pushRules.filter(_.productId.nonEmpty))</span>
<span class="nc" id="L44">      products &lt;- productDao.findByIds(projectId, pushRules.map(_.productId.get))</span>
<span class="nc" id="L45">      pushChannels &lt;- pushChannelDao.findByProject(projectId)</span>
<span class="nc" id="L46">      pushJob &lt;- pushJobDao.findById(projectId, jobId)</span>
    } yield {
<span class="nc bnc" id="L48" title="All 2 branches missed.">      logger.info(s&quot;total users query from insight is ${userInfos.size} and valid user size is ${validUsers.size} &quot; +</span>
<span class="nc" id="L49">        s&quot;for push task request: $pushTaskRequest&quot;)</span>
<span class="nc" id="L50">      val job = pushJob.getOrElse(PushJob.fromMessage(pushMessage))</span>
<span class="nc" id="L51">      appPushMessageService.buildJobContexts(validUsers, pushMessage, job, products, pushRules, pushChannels)</span>
<span class="nc" id="L52">        .foreach(sender ! TasksNeedCheckpoint(_))</span>
    }
  }

  private def filterValidUserInfo(userInfos: Seq[UserInfo], pushMessage: PushMessage): Future[Seq[UserInfo]] = {
<span class="nc bnc" id="L57" title="All 2 branches missed.">    val (illegalUsers, validUsers) = userInfos.partition(u =&gt; StringUtils.isAnyBlank(u.channel, u.domain, u.token))</span>
<span class="nc" id="L58">    val messageUid = pushMessage.uid</span>
<span class="nc" id="L59">    val filterResult = messageDuplicateService.filterUserInfo(validUsers, messageUid)</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (illegalUsers.nonEmpty) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">      logger.warn(s&quot;find illegal user insight result: ${illegalUsers.length} messageId: ${pushMessage.id}&quot;)</span>
    }
<span class="nc" id="L63">    filterResult</span>
  }
}

<span class="fc" id="L67">object BuildPushTaskActor {</span>

<span class="fc" id="L69">  def props(injector: Injector): Props = Props[BuildPushTaskActor](new BuildPushTaskActor(injector))</span>

<span class="fc" id="L71">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>